import datetime
import json
import logging
import shutil
from typing import Any, Dict, List, Tuple, Union

import pandas
import pandas as pd
import yfinance
from crewai.tools import BaseTool
from dotenv import load_dotenv
from langchain_core.language_models.chat_models import BaseChatModel
from pandasai import Agent
from pydantic import BaseModel, Field

from financial_agent_crewai.src.tools.general_tools import FilenameOutput, FilenameOutputList
from financial_agent_crewai.src.utils.config import *

logger = logging.getLogger(__name__)
load_dotenv()

DATE_COLUMN = 'Date'
FILENAME = 'report_yfinance_stocks'


# Prompt template
SOURCES_PROMPT_TEMPLATE = """
    Please consider the following data sources and determine
    the minimal set of data sources (and the corresponding original columns)
    that are the most relevant to the user query.

    Query: {query}

    \n\n
    Please preserve the original data source names and their corresponding column names listed below.
    Never invent new column names if you can't find a good match for the user query.
    \n

    Data sources: \n\n
"""

PANDASAI_FORMAT_INSTRUCTIONS_CONVERSATIONAL = (
    '\nPlease provide a well detailed conversational response of at least a few sentences.'
)

PANDASAI_FORMAT_INSTRUCTIONS_PLOT = '\nPlease provide PNG plots that illustrate the answer.'


class YFinanceSource(BaseModel):
    """A data source and the columns that is the most relevant to the user query."""

    name: str = Field(..., description='The relevant data source.')
    columns: List[str] = Field(
        ..., description='The list of relevant columns of the data source (in their original name and spelling).'
    )


class YFinanceSourceList(BaseModel):
    """The list of the data sources that are the most relevant to the user query."""

    sources: List[YFinanceSource] = Field(..., description='The list of relevant data sources.')


class YFinanceStocksTool(BaseTool):  # type: ignore
    name: str = "Search a txt's content."
    description: str = "A tool that can be used to semantic search a query from a txt's content."
    llm: BaseChatModel
    ticker_symbol: str
    start_date: datetime.date
    end_date: datetime.date

    def _run(self, query: str) -> FilenameOutputList:
        """Execute the search query and return results"""

        # Extract data from yfinance
        data = extract_yfinance_data(
            self.ticker_symbol,
            start_date=self.start_date,
            end_date=self.end_date,
        )

        PROMPT_TEMPLATE = SOURCES_PROMPT_TEMPLATE.format(query=query)
        for data_source in list(data):
            PROMPT_TEMPLATE += f'Data source: {data_source}.'
            PROMPT_TEMPLATE += data[data_source][1] + '\n\n'

        # Bind the schema to the model
        model_with_structure = self.llm.with_structured_output(YFinanceSourceList)

        # Invoke the model
        structured_output = model_with_structure.invoke(PROMPT_TEMPLATE)

        # Convert each DataFrame into a JSON string and store under its name
        answer_data_dict = dict()
        dataframe_dict = dict()
        meta_data_dict = dict()
        for source in structured_output.sources:  # type: ignore
            # Coerce the retrieved data to a `pandas.DataFrame`
            dataframe = convert_data_to_frame(data[source.name][0], source.name)
            columns = [column for column in source.columns]
            meta_data_dict[source.name] = data[source.name][1].strip('columns')

            dataframe_dict[source.name] = dataframe[columns]
            answer_data_dict[source.name] = dataframe[columns].to_json(orient='split')

        # Dump all DataFrame JSON strings into one file
        filename_json = CACHE_DIR / f'{FILENAME}_{self.ticker_symbol}.json'
        with open(filename_json, 'w') as f:
            json.dump(answer_data_dict, f, indent=2)

        # Answer the user query by symbol
        answer = interrogate_dataframe_pandasai(dataframe_dict, query, self.llm, self.ticker_symbol)

        # Save the answer to a text file
        filename_txt = CACHE_DIR / f'{FILENAME}_{self.ticker_symbol}.txt'
        with open(filename_txt, 'w') as f:
            f.write(answer)

        return FilenameOutputList(
            file_output_list=[FilenameOutput(filename=str(filename_txt)), FilenameOutput(filename=str(filename_json))]
        )


def interrogate_dataframe_pandasai(
    dataframe_dict: Dict[str, pandas.DataFrame],
    query: str,
    llm: BaseChatModel,
    ticker_symbol: str,
) -> Any:
    """
    Interrogate a dataframe via `pandasai` with the user query.

    Args:
        df_pandas: The dataframe to interrogate.
        query: The user query to answer with information from the dataframe.

    Returns:
        The response to the user query, generated by the LLM via `pandasai`.
    """
    pandasai_dataframes_list = [dataframe for dataframe in dataframe_dict.values()]
    pandasai_agent = Agent(
        pandasai_dataframes_list,
        config={
            'llm': llm,
            'open_charts': False,
            'save_charts': True,
            'save_charts_path': str(YFINANCE_STOCKS_DIR / f'{ticker_symbol}'),
            'enable_cache': False,
        },
    )

    # Delete the pandasai cache
    shutil.rmtree(PANDASAI_CAHE_DIR, ignore_errors=True)

    answer_conversational = pandasai_agent.chat(query + PANDASAI_FORMAT_INSTRUCTIONS_CONVERSATIONAL)

    answer_plot = pandasai_agent.chat(query + PANDASAI_FORMAT_INSTRUCTIONS_PLOT)

    return answer_conversational + '\n\n' + answer_plot


def convert_index_to_column(df: pd.DataFrame, column_name: str) -> pd.DataFrame:
    """
    Simple helper function that moves the index of a DataFrame into a new column.
    """
    df = df.reset_index()
    df.rename(columns={'index': column_name}, inplace=True)
    return df


def extract_yfinance_data(
    ticker_symbol: str, start_date: datetime.date, end_date: datetime.date
) -> Dict[str, Tuple[Union[pd.DataFrame, Dict[Any, Any], str, List[Any]], str]]:
    """
    Extracts all the data of a given company using Yahoo Finance for specified dates.
    Now each entry of the returned dictionary is a tuple consisting of:
      - The extracted object (DataFrame, dict, string, list, etc.)
      - A brief description of what information that object contains, ending with
        a guessed list of columns/key-names.

    Args:
        symbol: The ticker symbol of the company to extract data from.
        start_date: The start date of the historical price data to retrieve.
        end_date: The end date of the historical price data to retrieve.

    Returns:
        A dictionary where each key is a data-type label (e.g. "history", "info")
        and each value is a tuple (data_object, description_with_columns).

    Raises:
        TypeError: If `symbol` is not a string or `start_date` and `end_date` are not of type `datetime.date`.
    """
    # Check inputs
    if not isinstance(ticker_symbol, str):
        raise TypeError('Symbol must be a string.')
    if not isinstance(start_date, datetime.date):
        raise TypeError('Start date must be of type datetime.date.')
    if not isinstance(end_date, datetime.date):
        raise TypeError('End date must be of type datetime.date.')

    # Extract the data from Yahoo Finance for the given ticker symbol
    company = yfinance.Ticker(ticker=ticker_symbol)

    # Initialize the return dictionary
    company_dict: Dict[str, Tuple[Union[pd.DataFrame, Dict[Any, Any], str, List[Any]], str]] = {}

    def get_columns(data: Any) -> List[str]:
        """Get the names of the keys of a dictionary or of the columns of a dataframe."""

        if isinstance(data, pd.DataFrame):
            return list(data.columns)
        elif isinstance(data, pandas.Series):
            return [data.name]
        elif isinstance(data, dict):
            return list(data.keys())
        else:
            raise TypeError('Data must be of type dict or pd.DataFrame.')

    # 1) Get all the stock information
    try:
        data = company.info
        description = (
            'This dictionary contains general metadata about the company, including name, '
            'sector, industry, and contact details. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['info'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `info` dictionary.')

    # 2) Get historical market data
    try:
        data = company.history(start=start_date, end=end_date)
        description = (
            'This DataFrame contains the historical stock price data for the requested date range. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['history'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `history` dataframe.')

    # 3) Get meta information about the history
    data = company.history_metadata
    description = (
        'This dictionary contains metadata about the retrieved historical data (e.g., refresh times, extents). '
        f'Columns: {get_columns(data)}.'
    )
    company_dict['history_metadata'] = (data, description)

    # 4) Get actions
    try:
        data = company.actions
        description = (
            'This DataFrame shows the timeline of corporate actions (dividends and splits) if available, '
            'indexed by date. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['actions'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `actions` dataframe.')

    # 5) Get dividends
    try:
        data = company.dividends
        description = (
            'This Series shows the dividend distribution history, indexed by date. ' f'Columns: {get_columns(data)}.'
        )
        company_dict['dividends'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `dividends` dataframe.')

    # 6) Get splits
    try:
        data = company.splits
        description = (
            'This Series shows stock split events for the requested date range, indexed by date. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['splits'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `splits` dataframe.')

    # 7) Get capital gains
    try:
        data = company.capital_gains  # only for mutual funds & etfs
        description = (
            'This Series shows the capital gains distributions for mutual funds or ETFs if available, indexed by date. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['capital_gains'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `capital gains` dataframe.')

    # 8) Get share count
    try:
        data = company.get_shares_full(start=start_date, end=end_date)
        description = (
            'This DataFrame shows the number of shares outstanding over time (if provided). '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['shares'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `shares` dataframe.')

    # 9) Get financials - income statement
    try:
        data = company.income_stmt.T
        description = (
            'This DataFrame contains the annual income statement data, transposed to display each year/period. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['income_stmt'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `income_stmt` dataframe.')

    # 10) Get quarterly income statement
    try:
        data = company.quarterly_income_stmt.T
        description = (
            'This DataFrame contains the quarterly income statement data, transposed to display each period. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['quarterly_income_stmt'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `quarterly_income_stmt` dataframe.')

    # 11) Get balance sheet
    try:
        data = company.balance_sheet.T
        description = (
            'This DataFrame shows the annual balance sheet data, transposed per year/period. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['balance_sheet'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `balance_sheet` dataframe.')

    # 12) Get quarterly balance sheet
    try:
        data = company.quarterly_balance_sheet.T
        description = (
            'This DataFrame shows the quarterly balance sheet data, transposed per period. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['quarterly_balance_sheet'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `quarterly_balance_sheet` dataframe.')

    # 13) Get cash flow statement
    try:
        data = company.cashflow.T
        description = (
            'This DataFrame shows the annual cash flow statement, transposed per year/period. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['cashflow'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `cashflow` dataframe.')

    # 14) Get quarterly cash flow
    try:
        data = company.quarterly_cashflow.T
        description = (
            'This DataFrame shows the quarterly cash flow statement, transposed per period. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['quarterly_cashflow'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `quarterly_cashflow` dataframe.')

    # 15) Get major holders
    try:
        data = company.major_holders
        description = (
            "This DataFrame shows major direct holders of the company's stock if available. "
            f'Columns: {get_columns(data)}.'
        )
        company_dict['major_holders'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `major_holders` dataframe.')

    # 16) Get institutional holders
    try:
        data = company.institutional_holders
        description = (
            "This DataFrame lists institutional holders of the company's stock if available. "
            f'Columns: {get_columns(data)}.'
        )
        company_dict['institutional_holders'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `institutional_holders` dataframe.')

    # 17) Get mutual fund holders
    try:
        data = company.mutualfund_holders
        description = (
            "This DataFrame lists mutual fund holders of the company's stock if available. "
            f'Columns: {get_columns(data)}.'
        )
        company_dict['mutualfund_holders'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `mutualfund_holders` dataframe.')

    # 18) Get insider transactions
    try:
        data = company.insider_transactions
        description = (
            "This DataFrame shows insider transactions for the company's stock. " f'Columns: {get_columns(data)}.'
        )
        company_dict['insider_transactions'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `insider_transactions` dataframe.')

    # 19) Get insider purchases
    try:
        data = company.insider_purchases
        description = 'This DataFrame shows insider purchase activities. ' f'Columns: {get_columns(data)}.'
        company_dict['insider_purchases'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `insider_purchases` dataframe.')

    # 20) Get insider sales
    try:
        data = company.insider_roster_holders
        description = (
            'This DataFrame shows the roster of insiders or insider holders if available. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['insider_roster_holders'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `insider_roster_holders` dataframe.')

    # 21) Get sustainability
    try:
        data = company.sustainability
        description = (
            'This DataFrame contains environmental, social, and governance (ESG) metrics for the company. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['sustainability'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `sustainability` dataframe.')

    # 22) Get recommendations
    try:
        data = company.recommendations
        description = 'This DataFrame shows broker recommendations for the company. ' f'Columns: {get_columns(data)}.'
        company_dict['recommendations'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `recommendations` dataframe.')

    # 23) Get recommendations summary
    try:
        data = company.recommendations_summary
        description = (
            'This DataFrame provides a summary of broker recommendations for the company. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['recommendations_summary'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `recommendations_summary` dataframe.')

    # 24) Get upgrades/downgrades
    try:
        data = company.upgrades_downgrades
        description = 'This DataFrame tracks analyst upgrades and downgrades. ' f'Columns: {get_columns(data)}.'
        company_dict['upgrades_downgrades'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `upgrades_downgrades` dataframe.')

    # 25) Get future and historic earnings dates
    try:
        data = company.earnings_dates
        description = (
            'This DataFrame shows upcoming and past earnings dates, including reported EPS and estimates. '
            f'Columns: {get_columns(data)}.'
        )
        company_dict['earnings_dates'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `earnings_dates` dataframe.')

    # 26) Get ISIN code
    try:
        data = company.isin
        description = "This string represents the company's International Securities Identification Number (ISIN). "
        company_dict['isin'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `isin` code.')

    # 27) Get options expirations
    try:
        data = list(company.options)
        description = "This list shows the available option expiration dates for the company's stock, indexed by date. "
        company_dict['options'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `options` list.')

    # 28) Get news
    try:
        data = company.news
        description = 'This list shows recent news stories related to the company. '
        company_dict['news'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `news` dataframe.')

    # 29) Get option chain for specific expiration
    try:
        data = company.option_chain()
        description = (
            'This object contains the calls and puts DataFrames for the specified (default/latest) option expiration. '
        )
        company_dict['option_chain'] = (data, description)
    except Exception:
        logger.warning('Could not retrieve the `option chain` dataframe.')

    return company_dict


def convert_data_to_frame(data: Any, df_name: str) -> pandas.DataFrame:
    """
    Converts data to pandas DataFrame.

    Args:
        data: Data to be converted to DataFrame.
        df_name: Name of the DataFrame to be created.

    Returns:
        `pandas.DataFrame` object from the original data.

    Raises:
        `TypeError`: If the data not of type `pandas.DataFrame`, `pandas.Series`, `dict`, `list`, `tuple`, `str`.
    """
    if isinstance(data, pandas.DataFrame):
        df = data

    elif isinstance(data, pandas.Series):
        df = data.to_frame()

    elif isinstance(data, dict):
        for key, value in data.items():
            if is_unhashable(value):
                data[key] = json.dumps(value)
        df = pandas.Series(data, dtype=object).to_frame().T
        df.reset_index(inplace=True)

    elif isinstance(data, (list, tuple)):
        for item in data:
            item = json.dumps(item)
        df = pandas.DataFrame({df_name: data})

    elif isinstance(data, str):
        df = pandas.DataFrame({df_name: [data]})

    else:
        raise TypeError(f'Data type {type(data)} not supported.')

    # # Sort the dataframe by date
    # df = sort_dataframe_by_date(df)

    return df


# def sort_dataframe_by_date(df: pandas.DataFrame, column_name: Optional[str] = None) -> pandas.DataFrame:
#     """
#     Sort a pandas DataFrame by chronological dates.

#     This function checks if the `datetime` format is present in any of the DataFrame's columns.
#     If more than one column follows the datetime format, it prioritizes the column named DATE_COLUMN.
#     If DATE_COLUMN is not present, it takes the first occurrence among the columns.
#     The function then orders the rows by chronological dates from the earliest to the latest.

#     Args:
#         df: The input dataframe.
#         column_name (Optional): The name of the datetime column to sort by. Defaults to None.

#     Returns:
#         The dataframe ordered by the specified datetime column.
#     """
#     # Initialize the variable to store the name of the datetime column to sort by
#     datetime_col = column_name

#     if datetime_col is None:
#         # Iterate through the DataFrame columns to find datetime columns
#         for col in df.columns:
#             # Check if the column is of any datetime dtype
#             if (
#                 pandas.api.types.is_datetime64_any_dtype(df[col])
#                 or pandas.to_datetime(df[col], errors='coerce').notna().any()
#             ):
#                 # If the DATE_COLUMN column is found, select it
#                 if col == DATE_COLUMN:
#                     datetime_col = col
#                     break
#                 # Otherwise, set the first datetime column found
#                 elif datetime_col is None:
#                     datetime_col = col
#                     break

#     # If no datetime columns were found, log a message and return the original dataframe
#     if datetime_col is None:
#         logger.info('No datetime columns found in the DataFrame.')
#         return df

#     # Convert the selected datetime column to datetime type
#     df[datetime_col] = pandas.to_datetime(df[datetime_col], errors='coerce')

#     # Order the DataFrame by the datetime column
#     df_sorted = df.sort_values(by=datetime_col).reset_index(drop=True)

#     return df_sorted


def is_unhashable(input_object: Any) -> bool:
    """Determine whether an object is unhashable or not."""

    try:
        # Attempt to call hash() on the object
        hash(input_object)
    except TypeError:
        # If a TypeError occurs, the object is unhashable
        return True
    return False
